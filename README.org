#+STARTUP: fold indent
#+OPTIONS: tex:t toc:2 H:6 ^:{}

#+TITLE: Programming in R
#+AUTHOR: Derek Devnich
#+BEGIN_SRC R
#+END_SRC
#+BEGIN_SRC bash
#+END_SRC

* Introduction to R and RStudio
** Orientation
#+CAPTION: Building programs that support your research workflow.
#+NAME: Data science workflow
[[file:images/data-science-workflow.png]]
1. R was created by statisticians for statisticians (and other researchers)
2. R contains multitudes; this can be good and bad

** RStudio configuration
1. Don't save or restore .RData (General > Basic)
2. Use native pipe operator (Code > Editing)
3. Ctrl+Enter executes current line (Code > Editing)
4. Rainbow parentheses (Code > Display)
5. Adjust font and syntax colors (Appearance)
6. Move stuff around (Pane Layout)

** Workstation configuration
By default, your view of your file system will be opaque. We want to make it transparent (e.g. you may have a local Desktop and a cloud Desktop folder).

*** Mac OS Finder > Preferences
Your local Desktop folder is in your Home directory.
1. General
   1. New finder window shows: /Users/<home>
2. Sidebar
   1. Favorites: /Users/<home>
   2. iCloud: iCloud Drive
   3. Locations: <computer name>, Cloud Storage
3. Advanced
   1. Show all filename extensions
   2. Keep folders on top (all)

*** Windows System > File Explorer
Your local Desktop folder is in your Home directory or Computer directory.
1. File > Change folder and search options > View
   1. Files and Folders
      1. Show hidden files, folders, and drives
      2. Hide protected operating system files
      3. *Uncheck* Hide extensions for known file types
   2. Navigation Pane
      1. Show all folders
2. View
   1. File name extensions

** Coding in RStudio
1. Use both R scripts and R interactive console [REPL]
   #+BEGIN_SRC R
   print("hello")
   #+END_SRC

2. Test snippets in REPL
3. Run, Run Lines, and Run Current Line in script
4. Set working directory

** Introduction to R
*** Using R as a calculator
Begin with REPL, then move to script with comments

#+BEGIN_SRC R
1 + 100
(3 + 5) * 2  # operator precedence
5 * (3 ^ 2)  # powers
2/10000      # outputs 2e-04
2 * 10^(-4)  # 2e-04 explicated
#+END_SRC

*** Mathematical functions
1. Some functions need inputs ("arguments")
   #+BEGIN_SRC R
   getwd()      # no argument required
   sin(1)       # requires arg
   log(1)       # natural log
   #+END_SRC

2. RStudio has auto-completion
   #+BEGIN_SRC R
   log...
   #+END_SRC

3. Use ~help()~ to find out more about a function
   #+BEGIN_SRC R
   help(exp)
   exp(0.5)    # e^(1/2)
   #+END_SRC

*** Comparing things
1. Basic comparisons
   #+BEGIN_SRC R
   1 == 1
   1 != 2
   1 < 2
   1 <= 1
   #+END_SRC

2. Floating point numbers are tricky because of your computer's limits
   #+BEGIN_SRC R
   all.equal(3.0, 3.0)         # TRUE
   all.equal(2.9999999, 3.0)   # 7 places: Gives difference
   all.equal(2.99999999, 3.0)  # 8 places: TRUE
   2.99999999 == 3.0           # 8 places: FALSE
   #+END_SRC

*** Variables and assignment
1. R uses the assignment arrow (~Alt-Enter~ by default in RStudio; ~C-c C-=~ in ESS)
   #+BEGIN_SRC R
   # Assign a value to the variable name
   x <- 1/40
   #+END_SRC

2. You can inspect a variable's value in the Environment tab or by evaluating it in the console
   #+BEGIN_SRC R
   # Evaluate the variable and echo its value to the console
   x
   #+END_SRC

3. Variables can be re-used and re-assigned
   #+BEGIN_SRC R
   log(x)
   x <- 100
   x <- x + 1
   y <- x * 2
   #+END_SRC

4. Use a standard naming scheme for your variables
   #+BEGIN_SRC R
   r.style.variable <- 10
   python_style_variable <- 11
   javaStyleVariable <- 12
   #+END_SRC

*** Vectorization
Vectorize all the things! This makes idiomatic R very different from most programming languages.
#+BEGIN_SRC R
# Create a sequence 1 - 5
1:5

# Raise 2 to the Nth power for each element of the sequence
2^(1:5)

# Assign the resulting vector to a variable
v <- 2^(1:5)
#+END_SRC

*** Managing your  environment
#+BEGIN_SRC R
ls()             # List the objects in the environment
ls               # Echo the contents of ls(), i.e. the code
rm(x)            # Remove the x object
rm(list = ls())  # Remove all objects in environment
#+END_SRC

Note that parameter passing (~=~) is not the same as assignment (~<-~) in R!

*** R Packages
"Package" and "library" are roughly interchangeable.

1. Install additional packages
   #+BEGIN_SRC R
   install.packages("tidyverse")
   ## install.packages("rmarkdown")
   #+END_SRC

2. Activate a package for use
   #+BEGIN_SRC R
   library("tidyverse")
   #+END_SRC

*** Challenges 1 and 2
See /scripts/curriculum.Rmd

* Project management with RStudio
** General file management
See /scripts/curriculum.Rmd
#+BEGIN_EXAMPLE
project_name
├── project_name.Rproj
├── README.md
├── script_1.R
├── script_2.R
├── data
│   ├── processed
│   └── raw
├── results
└── temp
#+END_EXAMPLE

** Create projects with Rstudio
1. File > New Project
2. RStudio understands .Rproj files and will reopen everything for you

* Seeking help
** Basic help syntax
#+BEGIN_SRC R
help(write.csv)
?write.csv
#+END_SRC

** Help file format
1. Description
2. Usage
3. Arguments
4. Details
5. Examples (highlight and run with ~C-Enter~)

** Special operators
#+BEGIN_SRC R
help("<-")
#+END_SRC

** Library examples
#+BEGIN_SRC R
vignette("dplyr")
#+END_SRC

** What if you don't know where to start?
1. RStudio autocomplete
2. Fuzzy search
   #+BEGIN_SRC R
   ??set
   #+END_SRC
3. Browse by topic: https://cran.r-project.org/web/views/

* Data structures
** Data types
There are 5 basic (vector) data types.
#+BEGIN_SRC R
typeof(v)
typeof(3.14)
typeof(1L)
typeof(1+1i)
typeof(TRUE)
typeof("banana")
#+END_SRC

** Vectors and type coercion
1. Note that there are no scalars in R; everything is a vector, even if it's a vector of length 1.
   #+BEGIN_SRC R
   length(v)
   length(3.14)
   #+END_SRC

2. (Optional) New vectors are empty by default
   #+BEGIN_SRC R
   # Vectors are logical by default
   vector1 <- vector(length = 3)
   vector1

   # You can specify other types
   vector2 <- vector(mode="character", length = 3)
   vector2
   str(vector2)
   #+END_SRC

3. A vector must be all one type. If you mix types, R will perform type coercion.
   See coercion rules in scrips/curriculum.Rmd
   #+BEGIN_SRC R
   coercion_vector1 <- c(2, 6, '3')
   coercion_vector2 <- c(0, TRUE)

   coercion_vector1
   coercion_vector2
   #+END_SRC

4. You can change vector types
   #+BEGIN_SRC R
   # Create a character vector
   chr_vector <- c('0', '2', '4')
   str(chr_vector)

   # Use it to create a numeric vector
   num_vector <- as.numeric(chr_vector)
   str(num_vector)
   #+END_SRC

5. There are multiple ways to generate vectors
   #+BEGIN_SRC R
   # Two options for generating sequences
   series1 <- 1:10
   series2 <- seq(10)

   series1
   series2

   # The seq() function is more flexible
   series3 <- seq(1, 10, by=0.1)
   series3
   #+END_SRC

6. Manage your vectors
   #+BEGIN_SRC R
   # Don't print everything to the screen
   length(series3)
   head(series3, n=2)
   tail(series3, n=4)
   #+END_SRC

   #+BEGIN_SRC R
   # You can add informative labels to most things in R
   name_example <- 5:8
   names(name_example) <- c("a", "b", "c", "d")
   name_example
   str(name_example)
   #+END_SRC

** Challenge 3
See /scripts/curriculum.Rmd

** Factors
1. Factors represent unique levels (e.g., experimental conditions)
   #+BEGIN_SRC R
   coats <- c("tabby", "tortoise", "tortoise", "black", "tabby")
   str(coats)

   # The reprentation has 3 levels, some of which have multiple instances
   categories <- factor(coats)
   str(categories)
   #+END_SRC

2. R assumes that the first factor represents the baseline level, so you may need to change your factor ordering so that it makes sense for your variables
   #+BEGIN_SRC R
   trials <- c("case", "control", "control", "case")
   trial_factors <- factor(trials, levels = c("control", "case"))
   str(trial_factors)
   #+END_SRC

** Data Frames are central to working with tabular data
1. Create a data frame
   #+BEGIN_SRC R
   cats <- data.frame(coat = c("calico", "black", "tabby"),
                      weight = c(2.1, 5.0, 3.2),
                      likes_string = c(1, 0, 1))

   cats         # show contents of data frame
   str(cats)    # inspect structure of data frame

   # Convert likes_string to logical vector
   cats$likes_string <- as.logical(cats$likes_string)
   #+END_SRC

2. Write the data frame to a CSV and re-import it. You can use ~read.delim()~ for tab-delimited files, or ~read.table()~ for flexible, general-purpose input.
   #+BEGIN_SRC R
   write.csv(x = cats, file = "data/feline_data.csv", row.names = FALSE)
   cats <- read.csv(file = "data/feline_data.csv", stringsAsFactors = TRUE)

   str(cats) # the chr column is now a factor column
   #+END_SRC

3. Access the vectors of the data frame
   #+BEGIN_SRC R
   cats$weight
   cats$coat
   #+END_SRC

4. A vector can only hold one type. Therefore, in a data frame each data column (vector) has to be a single type.
   #+BEGIN_SRC R
   typeof(cats$weight)
   #+END_SRC

5. Use data frame vectors can be inputs like any other vector
   #+BEGIN_SRC R
   cats$weight + 2
   paste("My cat is", cats$coat)

   # Operations have to be legal for the data type
   cats$coat + 2

   # Operations are ephemeral unless their outputs are reassigned to the variable
   cats <- cats$weight + 1
   #+END_SRC

6. Data frames have column names
   #+BEGIN_SRC R
   names(cats)
   names(cats)[2] <- "weight_kg"
   names
   #+END_SRC

** Lists
1. Lists can contain anything
   #+BEGIN_SRC R
   list1 <- list(1, "a", TRUE, 1+4i)

   # Inspect each element of the list
   list1[[1]]
   list1[[2]]
   list1[[3]]
   list1[[4]]
   #+END_SRC

2. This includes complex data structures
   #+BEGIN_SRC R
   list2 <- list(title = "Numbers", numbers = 1:10, data = TRUE)

   # Single brackets retrieve a slice of the list, containing the name:value pair
   list2[2]

   # Double brackets retrieve the value, i.e. the contents of the list item
   list2[[2]]


   #+END_SRC

3. Data frames are lists of vectors and factors
   #+BEGIN_SRC R
   typeof(cats)
   #+END_SRC

4. Some operations return lists, others return vectors (basically, are you getting the column with its label, or are you drilling down to the data?)
   #+BEGIN_SRC R
   # List slices
   cats[1]      # list slice by index
   cats["coat"] # list slice by name
   cats[1, ]    # get data frame row by row number

   # List contents (in this case, vectors)
   cats[[1]]      # content by index
   cats[["coat"]] # content by name
   cats$coat      # content by name; shorthand for `cats[["coat"]]`
   cats[, 1]      # content by index, across all rows
   cats[1, 1]     # content by index, single row
   #+END_SRC

   1. You can inspect all of these with ~typeof()~
   2. Note that you can address data frames by row and columns

** Matrices
1. A matrix is 2-dimensional vector
   #+BEGIN_SRC R
   # Create a matrix of zeros
   mat1 <- matrix(0, ncol = 6, nrow = 3)
   mat2 <- matrix(1:25, nrow = 5, byrow = TRUE)

   # Inspect it
   class(mat1)
   typeof(mat1)
   str(mat1)
   #+END_SRC

2. Some operations act as if the matrix is a 1-D wrapped vector
   #+BEGIN_SRC R
   mat2 <- matrix(1:25, nrow = 5, byrow = TRUE)
   str(mat2)
   length(mat2)
   #+END_SRC

** Challenge 4
See /scripts/curriculum.Rmd

* Exploring data frames
#+BEGIN_SRC R
#+END_SRC
1. Adding columns
   #+BEGIN_SRC R
   age <- c(2, 3, 5)
   cbind(cats, age)
   cats                     # cats is unchanged
   cats <- cbind(cats, age) # overwrite old cats
   #+END_SRC

   #+BEGIN_SRC R
   # Data frames enforce consistency
   age <- c(2, 5)
   cats <- cbind(cats, age)
   #+END_SRC

2. Appending rows (remember, rows are lists!)
   #+BEGIN_SRC R
   newRow <- list("tortoiseshell", 3.3, TRUE, 9)
   cats <- rbind(cats, newRow)

   # Legal values added, illegal values are NA
   cats

   # Update the factor set
   levels(cats$coat) <- c(levels(cats$coat), "tortoiseshell")
   cats <- rbind(cats, list("tortoiseshell", 3.3, TRUE, 9))
   #+END_SRC

3. Removing missing data
   ~cats~ is now polluted with missing data
   #+BEGIN_SRC R
   na.omit(cats)
   cats
   cats <- na.omit(cats)
   #+END_SRC

4. Working with realistic data
   #+BEGIN_SRC R
   gapminder <- read.csv("data/gapminder_data.csv", stringsAsFactors = TRUE)

   # Get an overview of the data frame
   str(gapminder)
   dim(gapminder)

   # It's a list
   length(gapminder)
   colnames(gapminder)

   # Look at the data
   summary(gapminder$gdpPercap)  # summary varies by data type
   head(gapminder)
   #+END_SRC

** Challenge 5
See /scripts/curriculum.Rmd

* Subsetting data
** Subset by index
#+BEGIN_SRC R
v <- 1:5
#+END_SRC

*** Index selection
#+BEGIN_SRC R
v[1]
v[1:3]     # index range
v[c(1, 3)] # selected indices
#+END_SRC

*** Index exclusion
#+BEGIN_SRC R
v[-1]
v[-c(1, 3)]
#+END_SRC

** Subset by name
#+BEGIN_SRC R
letters[1:5]
names(v) <- letters[1:5]
#+END_SRC

*** Character selection
#+BEGIN_SRC R
v["a"]
v[names(v) %in% c("a", "c")]
#+END_SRC

*** Character exclusion
#+BEGIN_SRC R
v[! names(v) %in% c("a", "c")]
#+END_SRC

** (Optional) Extracting list elements
Single brackets get you subsets of the same type (~list -> list~, ~vector -> vector~, etc.). Double brackets extract the underlying vector from a list or data frame.
#+BEGIN_SRC R
# Create a new list and give it names
l <- replicate(5, sample(15), simplify = FALSE)
names(l) <- letters[1:5]

# You can extract one element
l[[1]]
l[["a"]]

# You can't extract multiple elements
l[[1:3]]
l[[names(l) %in% c("a", "c")]]
#+END_SRC

** Subsetting by logical operations
1. Explicitly set each item to TRUE or FALSE
   #+BEGIN_SRC R
   v[c(FALSE, TRUE, TRUE, FALSE, FALSE)]
   #+END_SRC

2. Evaluate the truth of each item, then produce the TRUE ones
   #+BEGIN_SRC R
   # Explicit version
   truth_vec <- v > 4
   v[truth_vec]

   # Implicit version
   v[v > 4]
   #+END_SRC

3. Combining logical operations
   #+BEGIN_SRC R
   v[v < 3 | v > 4]
   #+END_SRC

** Subsetting matrices
#+BEGIN_SRC R
m <- matrix(1:25, nrow = 5, byrow = TRUE)

# Matrices are just 2D vectors
m[2:4, 1:3]
m[c(1, 3, 5), c(2, 4)]
#+END_SRC

** (Optional) Subset by factor
#+BEGIN_SRC R
# First three items
gapminder$country[1:3]

# All items in factor set
north_america <- c("Canada", "Mexico", "United States")
gapminder$country[gapminder$country %in% north_america]
#+END_SRC

** Subsetting Data Frames
Data frames have characteristics of both lists and matrices.
#+BEGIN_SRC R
gapminder <- read.csv("data/gapminder_data.csv", stringsAsFactors = TRUE)

# Get first three rows
gapminder[1:3,]

# Rows and columns
gapminder[1:6, 1:3]
gapminder[1:6, c("country", "pop")]

# Data frames are lists, so one index gets you the *columns*
gapminder[1:3]

# Filter by contents
gapminder[gapminder$country == "Mexico",]
north_america <- c("Canada", "Mexico", "United States")
gapminder[gapminder$country %in% north_america,]
gapminder[gapminder$country %in% north_america & gapminder$year > 1999,]
#+END_SRC

* Vectorization
** Vector operations are element-wise by default
#+begin_src R
x <- 1:4
y <- 6:9
x + y
log(x)

# A more realistic example
gapminder$pop_millions <- gapminder$pop / 1e6
head(gapminder)
#+end_src

** Vectors of unequal length are recycled
#+begin_src R
z <- 1:2
x + z
#+end_src

** Logical comparisons
#+begin_src R
x > 2
a <- (x > 2) # you can assign the output to a variable

# Evaluate a boolean vector
any(a)
all(a)
#+end_src

** Matrix operations are also element-wise by default
#+begin_src R
m <- matrix(1:12, nrow=3, ncol=4)

# Multiply each item by -1
m * -1
#+end_src

** Linear algebra uses matrix multiplication
#+begin_src R
# Multiply two vectors
1:4 %*% 1:4

# Matrix-wise multiplication
m2 <- matrix(1, nrow = 4, ncol = 1)
m2
m %*% m2

# Most functions operate on the whole vector or matrix
mean(m)
sum(m)
#+end_src

** ~apply~ lets you apply an arbitrary function to an abitrary subset of a matrix. This is an example of a higher-order function (map, apply, filter, reduce, fold, etc.)
#+begin_src R
apply(m, 1, mean)
apply(m, 2, mean)
apply(m, 1, sum)
apply(m, 2, sum)
#+end_src

* Control flow
** Conditionals
1. Look at Conditional template in curriculum.Rmd
2. If
   #+BEGIN_SRC R
   x <- 8

   if (x >= 10) {
     print("x is greater than or equal to 10")
   }

   x
   #+END_SRC

3. Else
   #+BEGIN_SRC R
   if (x >= 10) {
     print("x is greater than or equal to 10")
   } else {
     print("x is less than 10")
   }
   #+END_SRC

4. Else If
   #+BEGIN_SRC R
   if (x >= 10) {
     print("x is greater than or equal to 10")
   } else if (x > 5) {
     print("x is greater than 5, but less than 10")
   } else {
     print("x is less than 5")
   }
   #+END_SRC

5. Vectorize your tests
   #+BEGIN_SRC R
   x <- 1:4

   if any(x < 2) {
     print("Some x less than 2")
   }

   if all(x < 2){
     print("All x less than 2")
   }
   #+END_SRC

** Review Subsetting section
Subsetting is frequently an alternative to if-else statements in R

** Iteration
1. Look at Iteration template in curriculum.Rmd
2. Basic For loop
   #+BEGIN_SRC R
   for (i in 1:10) {
     print(i)
   }
   #+END_SRC

3. Nested For loop
   #+BEGIN_SRC R
   for (i in 1:5) {
     for (j in c('a', 'b', 'c', 'd', 'e')) {
       print(paste(i,j))
     }
   }
   #+END_SRC

4. This is where we skip the example where we append things to the end of a data frame. For loops are slow, vectorize operations are fast (and idiomatic). Use for loops where they're the appropriate tool (e.g., loading files, cycling through whole data sets, etc). We will see more of this in the section on reading and writing data.

* Functions explained
Functions let you encapsulate and re-use chunks of code. This has several benefits:
1. Eliminates repetition in your code. This saves labor, but more importantly it reduces errors, and makes it easier for you to find and correct errors.
2. Allows you to write more generic (i.e. flexible) code.
3. Reduces cognitive overhead.

** Defining a function
1. Look at Function template in data/curriculum.Rmd
2. Define a simple function
   #+BEGIN_SRC R
   # Convert Fahrenheit to Celcius
   f_to_celcius <- function(temp) {
     celcius <- (temp - 32) * (5/9)
     return(celcius)
   }
   #+END_SRC

3. Call the function
   #+BEGIN_SRC R
   f_to_celcius(32)
   boiling <- f_to_celcius(212)
   #+END_SRC

** Combining functions
Define a second function and call the first function within the second.
#+BEGIN_SRC R
f_to_kelvin <- function(temp) {
  celcius <- f_to_celcius(temp)
  kelvin <- celcius + 273.15
  return(kelvin)
}

f_to_kelvin(212)
#+END_SRC

** Defensive programming
1. Check whether input meets criteria before proceeding (this is `assert` in other languages).
   #+BEGIN_SRC R
   f_to_celcius <- function(temp) {
     ## Check inputs
     stopifnot(is.numeric(temp), temp > -460)
     celcius <- (temp - 32) * (5/9)
     return(celcius)
   }

   f_to_celcius("a")
   f_to_celcius(-470)
   #+END_SRC

2. (Optional) Fail with a custom error if criterion not met
   #+BEGIN_SRC R
   f_to_celcius <- function(temp) {
     if(!is.numeric(temp)) {
       stop("temp must be a numeric vector")
     }
     celcius <- (temp - 32) * (5/9)
     return(celcius)
   }
   #+END_SRC

** Working with rich data
1. Write a function to perform a total GDP calculation on a filtered subset of your data.
   #+BEGIN_SRC R
   calcGDP <- function(df, year=NULL, country=NULL) {
     if(!is.null(year)) {
       df <- df[df$year %in% year, ]
     }
     if (!is.null(country)) {
       df <- df[df$country %in% country,]
     }
     gdp <- df$pop * df$gdpPercap

     new_df <- cbind(df, totalGDP=gdp)
     return(new_df)
   }
   #+END_SRC

2. Mutating `df` inside the function doesn't affect the global `gapminder` data frame (because of pass-by-value and scope).

** Challenge 6
See data/curriculum.Rmd

* Reading and writing data
** Create sample data sets and write them to the `data` directory
#+BEGIN_SRC R
for (year in unique(gapminder$year)) {
  df <- calcGDP(gapminder, year = year, country = north_america)

  ## Generate a file name
  fname <- paste("data/north_america_", as.character(year), ".csv", sep = "")

  ## Write the file
  write.csv(x = df, file = fname, row.names = FALSE)
}
#+END_SRC

** How to find files
#+BEGIN_SRC R
## Get matching files from the `data` subdirectory
dir(path = "data", pattern = "north_america_[1-9]*.csv")
#+END_SRC

** Read files using a for loop
1. Read each file into a data frame and add it to a list
   #+BEGIN_SRC R
   ## Create an empty list
   df_list <- list()

   ## Get the locations of the matching files
   file_names <- dir(path = "data", pattern = "north_america_[1-9]*.csv")

   for (f in file_names){
     df_list[[f]] <- read.csv(file = file.path("data", f))
   }
   #+END_SRC

2. Access the list items to view the individual data frames
   #+BEGIN_SRC R
   length(df_list)
   names(df_list)
   df_list[["north_america_1952.csv"]]
   #+END_SRC

** Read files using apply
1. Instead of a for loop that handles each file individually, use a single vectorized function.
   #+BEGIN_SRC R
   file_names <- dir(path = "data", pattern = "north_america_[1-9]*.csv")
   df_list <- lapply(file.path("data", file_names), read.csv)
   #+END_SRC

2. This doesn't add names by default, so you will have to add them manually
   #+BEGIN_SRC R
   ## You can still access by index position
   df_list[[2]]

   names(df_list)
   names(df_list) <- file_names
   df_list[["north_america_1952.csv"]]
   #+END_SRC

** Read files using apply with pipes
Pipes allow you to use an alternative formatting for collections of functions that can be easier to read.
#+BEGIN_SRC R
df_list <- file.path("data", file_names) |>
    lapply(read.csv)
#+END_SRC

** (Optional) Review using `apply` with matrices

* Data frame manipulation with dplyr
1. Explain Tidyverse briefly: https://www.tidyverse.org/packages/
2. Explain tibbles briefly

* Splitting and combining data frames with plyr
1. Briefly describe split-apply-combine
2. Aggregate files to a single dataframe

* Data frame manipulation with tidyr

* Creating publication-quality graphics with ggplot2

* Producing reports with knitr

* Writing good software

* IDE Reference
1. Clear console
   1. RStudio: ~C-l~
   2. Emacs: ~C-c M-o~ / ~M-x comint-clear-buffer~

* Credits
1. R for Reproducible Scientific Analysis: https://swcarpentry.github.io/r-novice-gapminder/
2. Andrea Sánchez-Tapia's workshop: https://github.com/AndreaSanchezTapia/UCMerced_R

* References
1. RStudio shortcuts and tips: https://appsilon.com/rstudio-shortcuts-and-tips/
2. CRAN task views: https://cran.r-project.org/web/views/
3. Why ~typeof()~ and ~class()~ give different outputs: https://stackoverflow.com/a/8857411
4. How to get function code from the different object systems: https://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function
5. Various approaches to contrast coding: https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/

   If you tell R that a factor is ordered, it defaults to Orthogonal polynomial contrasts. This means that it assumes you want it to check for linear, cubic, and quadratic trends. If you tell R that a factor is NOT ordered, it defaults to treatment contrasts: it compares all levels to a reference level. This probably doesn't make sense for lots of psych data. So if I say income is ordered, it calculates linear, quadratic etc. trends for income, which is not only not what I want, but is inappropriate unless your groups are evenly spaced. Treatment means it calculates whether each level is significantly different from a reference level (i.e. the highest income group).

   So if you want first-year stats output in a design with more than 2 levels in the factor, put this at the top of the R code:
   #+BEGIN_SRC R
   options(contrasts = c("contr.sum","contr.poly"))
   #+END_SRC

   ~contr.sum~ is R for deviation contrasts, which you may recall as contrasts like -1, 0, 1.

6. Instructor notes for "R for Reproducible Scientific Analysis"
   https://swcarpentry.github.io/r-novice-gapminder/guide/

* Data Sources
** Additional data files
1. Gapminder data:
   https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv
   https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_wide.csv

* COMMENT How to export this document to other formats
** Export to Markdown using Emacs Org mode
Do this if you want a table of contents on Github.
#+BEGIN_EXAMPLE
M-x org-md-export-to-markdown
#+END_EXAMPLE

** Export to Markdown using Pandoc
Do this if you want code syntax highlighting and a table of contents on Github.
*** Generate generic Markdown file
#+BEGIN_SRC bash
pandoc README.org -o tmp.md
#+END_SRC

*** Edit generic Markdown file to remove illegal front matter
1. Org directives
2. Anything that isn't part of the document structure (e.g. TODO items)

*** Generate Github Markdown with table of contents
#+BEGIN_SRC bash
pandoc -f markdown --toc --toc-depth=2 -s tmp.md -o README.md
#+END_SRC

*** Find and replace code block markers in final document
#+BEGIN_EXAMPLE
M-x qrr ` {.r org-language="R"}` `r`
M-x qrr ` {.r}` `r`
M-x qrr ` {.bash}` `bash`
#+END_EXAMPLE
